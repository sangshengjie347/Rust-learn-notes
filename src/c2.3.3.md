# 类型推导
Rust是静态类型语言，所以编译器在编译的时候都必须知道变量的类型，但这并不意味着所有的变量都需要进行类型注解，它会自己推导是什么类型。

+ **只有在它不知道变量是什么类型的时候**
  
+ **或者你指定变量类型的时候需要进行类型注解**

```rust
fn main() {
    let a = 100; //i32类型
    println!("a is {}", a);
    let a: i64 = 100; //i64类型  我想它是i64类型 这时候我们在变量名后面加`:` 以及对应的类型
    //还可以这么表示
    println!("a is {}", a);
    let a = 100u8; //u8类型
    println!("a is {}", a);
    let a = 100_u8; //_在数字中只增加可读性 并不会影响数字的值
    println!("a is {}", a);
    let a = 100_000;
    println!("a is {}", a);
    
    //我们还可以使用as关键字进行类型转换
    let a = 10.2; //默认f64
    let b = 10.2f32 as f64;
    println!("a + b is {}", a+b);
    
    //加减乘除运算类型必须一致，如果不一致会导致编译不通过，但你不需要所有变量类型都进行注解。
    // 你只需要对一个变量进行类型注解，编译器会帮你推导出其他的变量类型。
    let a = 10u8;
    let b = 20; //不进行类型注解，通常这个时候默认i32类型
    let c = a + b ; //这个时候 要进行相加 类型一致 ，所以a,b,c都选择了u8类型
    println!("c is {}", c);
}
```

## 常量
我们之前讲变量它默认是不可以改变的，这其实和我们接触过的常量类似，但常量和变量区别还是有的。

+ 首先声明常量不是用`let`关键字而是用`const`。

+ 同时命名习惯我们将常量所有字母都大写，如果存在多个单词我们使用`_`来分隔增加可读性。

+ 必须显式的标注常量的类型，它不会自动推导类型。

```rust
fn main() {
    const MAX_POINT: i32 = 100;  // 类型注解不能省略
    println!("MAX_POINT is {}", MAX_POINT);
}
```
