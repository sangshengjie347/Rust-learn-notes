# HashMap和其他集合
HashMap是由keys和values组成的集合。你使用键来查找与键匹配的值。你可以只用`HashMap::new()`创建一个新的HashMap，并使用`.insert(key, value)`来插入元素。

可以通过`get`方法来获取到对应的值，它会返回一个`Option`,如果`存在则返回Some(value)`,如果`不存在则返回None`。
`entry`来检查键是否绑定了一个值，结合`or_insert`如果只有键，没有对应的值则插入。这个键可以不存在也可以没有相关联的值。


我们可以根据一个旧值来更新一个值，`or_insert`方法会返回这个键对应的值是一个可变引用，我们更新它的值先将它解引用，进行更新
```rust
use std::collections::HashMap;

fn main() {
    let mut collections = HashMap::new();
    collections.insert(1, "Beijing".to_string());
    collections.insert(2, "Shanghai".to_string());
    collections.insert(3, "Hangzhou".to_string());
    println!("{:?}", collections);
    //HashMap里面的值是无序的，同时打印它们多次打印出现的顺序可能都不同
    //{2: "Shanghai", 3: "Hangzhou", 1: "Beijing"}
    //{3: "Hangzhou", 1: "Beijing", 2: "Shanghai"}

    //如果HashMap有一个键，我们将它放进去时，它会覆盖原来的值
    collections.insert(1, "Nanjing".to_string());
    println!("{:?}", collections);
    //{1: "Nanjing", 3: "Hangzhou", 2: "Shanghai"}
    collections.entry(1).or_insert("Chongqing".to_string()); //有值不插入
    println!("{:?}", collections);

    collections.entry(4).or_insert("Sanya".to_string());
    println!("{:?}", collections);

    let text = "hello world wonderful world";
    let mut map = HashMap::new();
    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }
    println!("map is {:?}", map);
    let a = collections.get(&1);
    println!("a is {:?}", a);
}

```

# 其他集合
BTreeMap 和 HashMap 的区别是它是有序的，而HashMap是无序的。

```rust
use std::collections::BTreeMap;
fn main() {
    //将HashMap替换成BTreeMap
    let mut collections = BTreeMap::new();
    collections.insert(1, "Beijing".to_string());
    collections.insert(2, "Shanghai".to_string());
    collections.insert(3, "Hangzhou".to_string());
    println!("{:?}", collections);
    //  打印结果 BTreeMap会按顺序打印
    //{1: "Beijing", 3: "Hangzhou", 2: "Shanghai"}
    // {1: "Beijing", 2: "Shanghai", 3: "Hangzhou"}
    
}
```